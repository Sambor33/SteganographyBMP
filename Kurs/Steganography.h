/**
* @file Steganography.h
* @author Самборский И.С.
* @version 1.0
* @brief Описание класса Steganography
* @date 30.05.2021
* @copyright ИБСТ ПГУ
*/
#pragma once
#include <iostream>
#include <fstream>
#include <string>
#include <locale>
using namespace std;
///@brief Класс для реализации стеганографии в BMP изображениях методом LSB.
///@warning Реализация только для степени кодирования, равной 1/2/4/8.
class Steganography
{
private:
    /**
    * @brief Степень кодирования
    * @details Степень кодирования определяет количество последних бит в байте изображения, которые будут использоваться как
    * контейнер для бит скрываемой информации. Чем больше степень кодирования, тем сильнее отличается исходный-файл контейнер от 
    * файла-контейнера с скрываемой информацией.
    **/
    int degree;
    /**
    * @brief Метод, формирующий битовую маску для байта файла, информацию из которого необходимо скрыть.
    * @details Метод формирует маску, в которой оставляет единичными только первые degree битов. Маска используется при
    * операции сокрытия.
    * @return Маска для файла со скрываемой информацией.
    **/
    unsigned char hmask ();
    /**
    * @brief Метод, формирующий битовую маску для байта Bmp контейнера.
    * @details Метод формирует маску, в которой обнуляет последние degree бит. Маска используется при операции сокрытия, а также
    * противоположная ей маска используется при операции извлечения.
    * @return Маска для Bmp контейнера.
    **/
    unsigned char imask ();
public:
    /**
    * @brief Конструктор класса стеганографии, инициализирующий объект класса определенной степенью кодирования.
    * @param key - степень кодирования, вводимая пользователем.
    * @details Полученная степень кодирования в виде строки проверяется на корректность ввода, после чего с помощью
    * функции stoi инициализируется приватным полем degree целочисленным типом int.
    **/
    Steganography (const string&key);
    /**
     * @brief Метод сокрытия информации в файле-контейнере
     * @param bmp_path - путь к файлу-контейнеру
     * @param hidden_path - путь к скрываемому файлу
     * @details После создания объектов-файлов осуществляется их проверка функциями 
     * класса исключений на корректность формата файла-контейнера и возможность открытия файлов.
     * Переменная hiddensize хранит в себе размер скрываемого файла. Переменные Image,Hidden,ImageByte и
     * HiddenByte моделируют байты используемых файлов. Далее запускается цикл, работающий следующим образом:
     * пока не будет считано количество байт, равное объему скрываемого файла считываются байты скрываемого файла.
     * @code
       for (int i=0; i<hiddensize; i++) {
        hidden.read (reinterpret_cast<char*>(&Hidden),sizeof(unsigned char));
     * @endcode
     * После считывания одного байта его размер в битах делится на степень кодирования, именно столько итераций 
     * внутреннего цикла приходится на 1 байт скрываемой информации. Во внутреннем цикл считывает байт контейнера,
     * в котором обнуляются последние degree битов c помощью соответствующей маски. В байте скрываемой информации в свою очередь 
     * единичными битами остаются только первые degree битов. Далее происходит сдвиг этих битов в конец байта скрываемой информации 
     * и сложение двух модифицированных байтов (файла-контейнера и скрываемого файла). 
     * Полученный файл записывается обратно в файл-контейнер на то же место, а в байте скрываемой информации делается сдвиг 
     * на степень кодирования, чтобы продолжать успешно «цеплять» биты и отправлять их в конец байтов контейнера.
     * @code
       for (int i=0; i<8; i+=degree) {
            bmp.read(reinterpret_cast <char*>(&Image), sizeof(char));
            bmp.seekg(-1,fstream::cur);
            ImageByte = Image&imask();
            HiddenByte = Hidden&hmask();
            HiddenByte >>= (8-degree);
            ImageByte |= HiddenByte;
            bmp.write (reinterpret_cast <char*>(&ImageByte), sizeof(char));
            Hidden<<=degree;
        }
     * @endcode
     * После завершения внешнего цикла файлы закрываются и функция завершает свою работу.
     */
    int Concealment (const string&bmp_path,const string&hidden_path);
    /**
     * @brief Метод извлечения скрываемой информации из файла-контейнера
     * @param bmp_path - путь к файлу-контейнеру
     * @param hidden_path - путь к новому файлу, куда будет извлечена скрываемая информация
     * @param hiddensize - размер скрываемой информации в байтах, задается пользователем
     * @details После создания объектов-файлов метод проверяет файл-контейнер на формат BMP и возможность открытия. 
     * Также происходит проверка нового файла на возможность создания, а также проверяется количество байт, указанное пользователем 
     * на корректность ввода и на возможность извлечь данное количество байт из контейнера.  Переменная Image моделирует байт контейнера 
     * без изменений, тогда как переменная ImageByte моделирует байт контейнера после применения к нему маски, 
     * противоположной маске для файла-контейнера при сокрытии. Переменная Symbol моделирует байт, который после заполнения будет записан в новый файл.
     * Далее запускается цикл, в котором инициализируются байты, пока их количество не станет равно кол-ву байтов, заданному пользователем для извлечения
     * @code 
       for (int i=0; i<DigitHiddenSize; i++) {
        unsigned char Symbol = 0;
     * @endcode 
     * Затем во внутреннем цикле, который проходит столько раз , чему равно отношение размера байт (8) к степени кодировки,
     * считывается байт из файла-контейнера с скрываемой информацией. К нему применяется маска, которая обнуляет первые degree битов.
     * Далее этот байт контейнера складывается с созданным в цикле байтом. Далее записанные байты сдвигаются влево на degree, 
     * чтобы созданный в цикле байт полностью заполнялся. После окончания внутреннего цикла заполненный байт записывается в новый файл.
     * @code 
       for (int i=0; i<8; i+=degree) {
            bmp.read(reinterpret_cast <char*>(&Image),sizeof(char));
            ImageByte = Image&image_mask;
            Symbol<<=degree;
            Symbol |= ImageByte;
        }
        hidden.write (reinterpret_cast<char*>(&Symbol),sizeof(unsigned char));
     * @endcode 
     * После завершения внешнего цикла файлы закрываются и функция завершает свою работу.
     */
    int Extraction (const string&bmp_path,const string&hidden_path,const string&hiddensize);
};
